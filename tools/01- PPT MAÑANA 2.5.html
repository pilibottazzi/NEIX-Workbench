<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PPT MAÑANA</title>

  <!-- XLSX -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <!-- CSS externo con estética del dashboard -->
  <link rel="stylesheet" href="/static/css/general.css">
</head>
<body>
  <div class="wrap">
    <header class="topbar">
      <div class="brand">
        <div class="logo">
          N
        </div>
        <div>
          <h1>☀️ MOC MAÑANA</h1>
          <p>Papel de Trabajo Definitivo</p>
        </div>
      </div>
      <a href="/" class="back">← Volver</a>
    </header>

    <div class="card">
      <div class="row">
        <div class="col">
          <label for="fileMOC"> <u>MOC</u> (xlsx)</label>
          <input id="fileMOC" type="file" accept=".xlsx" />
        </div>
        <!-- MOC MAE (csv) -->
        <div class="col">
          <label for="fileMAE"> <u>MOC MAE</u> (csv)</label>
          <input id="fileMAE" type="file" accept=".csv" />
        </div>
        <div class="col">
          <label for="fileNeg"> <u>Saldos Negativos</u> (xlsx)</label>
          <input id="fileNeg" type="file" accept=".xlsx" />
        </div>
        <div class="col">
          <label for="fileAsignaciones"> <u>Asignaciones Pendientes</u> (xls) - Opcional</label>
          <input id="fileAsignaciones" type="file" accept=".xls,.xlsx,.xlsb" />
        </div>
        <div class="col">
          <label for="fileLista"> <u>Lista de Saldos BYMA</u> (xls)</label>
          <input id="fileLista" type="file" accept=".xls,.xlsx,.xlsb" />
        </div>
        <div class="col">
          <label for="fileNeix"> <u>Emisiones 992</u> (xlsx)</label>
          <input id="fileNeix" type="file" accept=".xlsx" />
        </div>
        <div class="col">
          <label for="fileSLIQ"> <u>Control SLIQ</u> (csv)</label>
          <input id="fileSLIQ" type="file" accept=".csv" />
        </div>
      </div>

      <div class="btns">
        <button id="btnValidar">Validar</button>
        <button id="btnExport" class="secondary">Exportar MOC</button>
        <button id="btnExportVentas" class="secondary">Exportar VENTAS</button>
      </div>

      <div id="status" style="margin-top:12px;display:grid;gap:8px"></div>
      <div class="hr"></div>
    </div>
  </div>

  <script>
    const $ = sel => document.querySelector(sel);
    const statusEl = document.getElementById('status');
    const setTag = (txt, cls) => {
      const div=document.createElement('div');
      div.className=`tag ${cls}`;
      div.textContent=txt;
      statusEl.appendChild(div);
    };

    const readWorkbook = async (file) => new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => {
        try {
          resolve(XLSX.read(new Uint8Array(fr.result), {type:'array', cellDates:true, raw:true}));
        } catch(e){ reject(e); }
      };
      fr.onerror = reject;
      fr.readAsArrayBuffer(file);
    });

    // =========================
    // CSV robusto (detecta ; / , y salta filas vacías tipo ";;;;;;")
    // =========================
    function detectDelimiter(line){
      const sc = (line.match(/;/g) || []).length;
      const cc = (line.match(/,/g) || []).length;
      return (sc >= cc) ? ';' : ',';
    }

    function parseCSVLine(line, delim){
      // Parser simple (soporta comillas dobles básicas)
      const out = [];
      let cur = '';
      let inQuotes = false;

      for (let i=0; i<line.length; i++){
        const ch = line[i];

        if (ch === '"'){
          if (inQuotes && line[i+1] === '"'){ // escape ""
            cur += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
          continue;
        }

        if (!inQuotes && ch === delim){
          out.push(cur);
          cur = '';
          continue;
        }

        cur += ch;
      }
      out.push(cur);
      return out;
    }

    function csvTextToAOA(text){
      const lines = (text || '')
        .replace(/\r\n/g, '\n')
        .replace(/\r/g, '\n')
        .split('\n');

      // Buscar primera línea "útil" (no vacía y no solo separadores)
      let firstUseful = '';
      for (const ln of lines){
        const t = (ln || '').trim();
        if (!t) continue;
        // si es tipo ";;;;;;" o ",,,,,," -> no es útil
        if (/^[;,]+$/.test(t)) continue;
        firstUseful = ln;
        break;
      }
      const delim = detectDelimiter(firstUseful || ';');

      const aoa = [];
      for (const ln of lines){
        const raw = (ln ?? '').trim();
        if (!raw) continue;
        if (/^[;,]+$/.test(raw)) continue; // salta ";;;;;;"
        aoa.push(parseCSVLine(ln, delim).map(v => (v ?? '').trim()));
      }
      return aoa;
    }

    const readCSVToAOA = async (file) => new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => {
        try {
          const aoa = csvTextToAOA(fr.result);
          resolve(aoa);
        } catch(e){ reject(e); }
      };
      fr.onerror = reject;
      fr.readAsText(file);
    });

    const sheetToAOA = ws => XLSX.utils.sheet_to_json(ws, {header:1, raw:true});
    const aoaToSheet = aoa => XLSX.utils.aoa_to_sheet(aoa);

    // Normalizadores
    const canon = (s)=> (s==null?'':String(s))
      .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
      .replace(/\s+/g,' ').trim().toUpperCase();

    const trimHeaders = (aoa) => {
      if (!aoa || !aoa.length) return aoa;
      const headers = (aoa[0]||[]).map(h => typeof h==='string' ? h.replace(/\s+/g,' ').trim() : h);
      return [headers, ...aoa.slice(1)];
    };

    const coerceNumber = v => {
      if (v===null || v===undefined || v==='') return null;
      if (typeof v === 'number') return v;
      if (typeof v === 'string'){
        const t = v.replace(/\./g,'').replace(/,/g,'.').replace(/\s+/g,'').trim();
        const n = Number(t);
        return Number.isFinite(n)? n : null;
      }
      return null;
    };

    const withHeaderRow2 = (aoa) => (!aoa || aoa.length<2) ? aoa : [aoa[1], ...aoa.slice(2)];

    const formatDateShort = (val) => {
      if (!val) return '';
      if (val instanceof Date) {
        const d = String(val.getDate()).padStart(2,'0');
        const m = String(val.getMonth()+1).padStart(2,'0');
        const y = val.getFullYear();
        return `${d}/${m}/${y}`;
      }
      if (typeof val === 'string') {
        const m = val.match(/^(\d{2})\/(\d{2})\/(\d{4})/);
        if (m) return `${m[1]}/${m[2]}/${m[3]}`;
      }
      return val;
    };

    // =========================
    // ASIGNACIONES (igual que antes)
    // =========================
    const REQUIRED_ASIG = [
      'Nro. Mercado Corto','Moneda','Cantidad','Monto','Fecha Concertación','Fecha Liquidación','CUIT','Negociación','Participante contraparte','Compra - Venta','Código Especie','Código CV','Código Liquidación'
    ];
    const REQUIRED_CANON = REQUIRED_ASIG.map(canon);
    function transformASIGN(aoa){
      if (!aoa || !aoa.length) return aoa;
      let out = trimHeaders(aoa);
      const H = out[0], Hcanon = H.map(canon);
      const idxMap = REQUIRED_CANON.map(req => Hcanon.indexOf(req));
      const newHeader = [...REQUIRED_ASIG, 'Observacion'];
      const res = [newHeader];
      for (let r=1; r<out.length; r++){
        const row=[]; for (let k=0;k<idxMap.length;k++){ const i=idxMap[k]; row.push(i>=0 ? out[r][i] : ''); }
        row.push(''); res.push(row);
      }
      const numericSet = new Set(['CANTIDAD','MONTO','CODIGO CV','CODIGO LIQUIDACION']);
      const dateSet = new Set(['FECHA CONCERTACION','FECHA LIQUIDACION']);
      const canonHeader = newHeader.map(canon);
      for (let r=1; r<res.length; r++){
        for (let c=0; c<res[0].length; c++){
          const h = canonHeader[c];
          if (numericSet.has(h)) res[r][c] = coerceNumber(res[r][c]);
          if (dateSet.has(h))   res[r][c] = formatDateShort(res[r][c]);
        }
      }
      return res;
    }

    // =========================
    // MOC (MAE entre Ventas y Neto)
    // =========================
    function transformMOCv2(aoa){
      if (!aoa || !aoa.length) return aoa;
      const norm = trimHeaders(withHeaderRow2(aoa));
      const H = norm[0].map(canon);
      const idx = {
        CODIGO:   H.indexOf('CODIGO'),
        COMITENTE:H.indexOf('COMITENTE'),
        COMPRAS:  H.indexOf('COMPRAS'),
        VENTAS:   H.indexOf('VENTAS'),
        NETO:     H.indexOf('NETO')
      };
      const outH = ['Comitente','Codigo','Compras','Ventas','MAE','Neto','Observaciones'];
      const out = [outH];
      for (let r=1;r<norm.length;r++){
        const row = norm[r];
        const com  = idx.COMITENTE>=0? coerceNumber(row[idx.COMITENTE]) : null;
        const cod  = idx.CODIGO>=0? row[idx.CODIGO] : '';
        const comp = idx.COMPRAS>=0? coerceNumber(row[idx.COMPRAS]) : null;
        const vent = idx.VENTAS>=0? coerceNumber(row[idx.VENTAS]) : null;
        out.push([com, cod, comp, vent, 0, 0, '']);
      }
      return out;
    }

    // =========================
    // SALDOS NEGATIVOS
    // =========================
    function transformNEGv2(aoa){
      if (!aoa || !aoa.length) return aoa;
      const norm = trimHeaders(withHeaderRow2(aoa));
      const H = norm[0].map(canon);
      const idx = { CODIGO:H.indexOf('CODIGO'), COMITENTE:H.indexOf('COMITENTE'), CANTIDAD:H.indexOf('CANTIDAD'), NETO:H.indexOf('NETO'), SALDO_NEG:H.indexOf('SALDO NEGATIVOS') };
      const outH = ['Comitente','Codigo','Neto','Cantidad','Saldo Negativos'];
      const out = [outH];
      for (let r=1;r<norm.length;r++){
        const row=norm[r];
        out.push([
          idx.COMITENTE>=0? coerceNumber(row[idx.COMITENTE]) : null,
          idx.CODIGO>=0?    coerceNumber(row[idx.CODIGO])    : null,
          idx.NETO>=0?      coerceNumber(row[idx.NETO])      : null,
          idx.CANTIDAD>=0?  coerceNumber(row[idx.CANTIDAD])  : null,
          idx.SALDO_NEG>=0? coerceNumber(row[idx.SALDO_NEG]) : null
        ]);
      }
      return out;
    }

    // =========================
    // BYMA
    // =========================
    function mapBYMAComitente(c){ const n=coerceNumber(c); return (n===3||n===777777777||n===888888888)?999:n; }
    function buildBymaMap(aoa){
      if (!aoa || !aoa.length) return new Map();
      const norm = trimHeaders(withHeaderRow2(aoa));
      const H = norm[0].map(canon);
      const iCom = H.indexOf('COMITENTE'), iCod = H.indexOf('CODIGO TV'), iTot = H.indexOf('TOTAL');
      const map = new Map();
      for (let r=1;r<norm.length;r++){
        const com = mapBYMAComitente(norm[r][iCom]);
        const cod = coerceNumber(norm[r][iCod]);
        const tot = coerceNumber(norm[r][iTot]) || 0;
        if (com==null || cod==null) continue;
        const key=com+'|'+cod;
        map.set(key, (map.get(key)||0) + tot);
      }
      return map;
    }

    // MODIFICADA: ahora puede usar maeMap para OTROS (solo cuando hay match)
    function mergeBymaToNeg(aoaNeg, bymaMap, maeMap, useMaeForOtros){
      if (!aoaNeg || aoaNeg.length===0) return aoaNeg;
      const hdr = aoaNeg[0], body = aoaNeg.slice(1);
      const outHdr = [...hdr, 'Garantías BYMA', 'OTROS', 'Total', 'Observación'];
      const out = [outHdr];

      for (const r of body){
        const com = coerceNumber(r[0]);
        const cod = coerceNumber(r[1]);

        const byma = bymaMap.get(com+'|'+cod) || 0;
        const saldo = coerceNumber(r[4]) || 0;

        let otros = 0; // default: no match => no agregamos nada
        if (useMaeForOtros && maeMap && maeMap.size){
          const keyMae = com + '|' + canon(cod);
          const vMae = maeMap.get(keyMae);
          if (vMae != null) {
            otros = vMae; // match => REEMPLAZAMOS valor por MAE
          }
        }

        const total = saldo + byma + otros;
        const obs = (total>=0 ? 'OK' : 'REVISAR');
        out.push([...r, byma, otros, total, obs]);
      }
      return out;
    }

    // =========================
    // EMISIONES 992 (igual que antes)
    // =========================
    function buildNeixMap(aoa){
      if (!aoa || !aoa.length) return new Map();
      const norm = trimHeaders(withHeaderRow2(aoa));
      const H = norm[0].map(canon);

      const iCode = H.indexOf('CSVA CODE');
      const iSym  = H.indexOf('SYMBOL');
      const iQty  = H.indexOf('QTY BYMA');
      const iTipo = H.indexOf('TIPO');
      const iOp   = H.indexOf('OPERACION');

      const map = new Map();

      for (let r=1; r<norm.length; r++){
        const code = coerceNumber(norm[r][iCode]);
        if (code == null) continue;

        const tipo = iTipo >= 0 ? canon(norm[r][iTipo]) : '';
        const op   = iOp   >= 0 ? canon(norm[r][iOp])   : '';

        const allowed = (tipo==='CEDEAR' && op==='ISSUE') || (tipo==='ADR' && op==='CXL');

        const qtySrc = iQty >= 0 ? coerceNumber(norm[r][iQty]) : 0;
        const qtyRow = allowed ? Math.abs(qtySrc || 0) : 0;

        const prev   = map.get(code) || { symbol:'', qty:0 };
        const symbol = prev.symbol || (iSym >= 0 ? (norm[r][iSym] ?? '') : '');

        map.set(code, { symbol, qty: prev.qty + qtyRow });
      }
      return map;
    }

    function applyNeixToNeg992(aoaNeg992, neixMap){
      if (!aoaNeg992 || aoaNeg992.length === 0) return aoaNeg992;
      const hdr = aoaNeg992[0];
      const out = [[...hdr, 'Symbol', 'Qty BYMA']];
      for (let i = 1; i < aoaNeg992.length; i++){
        const r = aoaNeg992[i];
        const cod = coerceNumber(r[1]);
        const ne = neixMap.get(cod) || { symbol: '', qty: 0 };
        const qty = Math.abs(ne.qty || 0);
        out.push([...r, ne.symbol ?? '', qty]);
      }
      return out;
    }

    function reorderNeg992(aoa){
      if (!aoa || aoa.length===0) return aoa;
      const hdr = aoa[0];
      const Hc = hdr.map(canon);

      const idx = {
        COM: Hc.indexOf('COMITENTE'),
        SYM: Hc.indexOf('SYMBOL'),
        COD: Hc.indexOf('CODIGO'),
        NET: Hc.indexOf('NETO'),
        CANT: Hc.indexOf('CANTIDAD'),
        SALDO: Hc.indexOf('SALDO NEGATIVOS'),
        QTY: Hc.indexOf('QTY BYMA'),
        BYMA: Hc.indexOf('GARANTIAS BYMA'),
        OTROS: Hc.indexOf('OTROS'),
        TOTAL: Hc.indexOf('TOTAL'),
        OBS: Hc.indexOf('OBSERVACION')
      };

      const outHdr = ['Comitente','Symbol','Codigo','Neto','Cantidad','Saldo Negativos','Qty BYMA','Garantías BYMA','OTROS','Total','Observación'];
      const out = [outHdr];

      for (let r=1; r<aoa.length; r++){
        const row = aoa[r];
        const pick = (i)=> i>=0 ? row[i] : '';
        out.push([
          pick(idx.COM), pick(idx.SYM), pick(idx.COD), pick(idx.NET), pick(idx.CANT),
          pick(idx.SALDO), pick(idx.QTY), pick(idx.BYMA), pick(idx.OTROS), pick(idx.TOTAL), pick(idx.OBS)
        ]);
      }
      return out;
    }

    // =========================
    // SLIQ (igual que antes)
    // =========================
    function normalizeCodeKey(v){
      const num = coerceNumber(v);
      if (num !== null && num !== undefined && !Number.isNaN(num)) return String(num);
      const s = (v == null ? '' : String(v));
      return canon(s);
    }

    function buildMocNetoMapWithLabel(aoaMOC){
      const res = { map:new Map(), label:new Map() };
      if (!aoaMOC || aoaMOC.length < 2) return res;
      const Hc = aoaMOC[0].map(canon);
      const iCodigo = Hc.indexOf('CODIGO');
      const iComp   = Hc.indexOf('COMPRAS');
      const iVent   = Hc.indexOf('VENTAS');
      if (iCodigo < 0 || iComp < 0 || iVent < 0) return res;
      for (let r=1; r<aoaMOC.length; r++){
        const row = aoaMOC[r];
        const codeRaw = (row[iCodigo] == null ? '' : String(row[iCodigo]));
        const codeKey = normalizeCodeKey(codeRaw);
        const comp = coerceNumber(row[iComp]) || 0;
        const vent = coerceNumber(row[iVent]) || 0;
        const total = comp + vent;
        if (!codeKey) continue;
        res.map.set(codeKey, (res.map.get(codeKey)||0) + total);
        if (!res.label.has(codeKey)) res.label.set(codeKey, codeRaw);
      }
      return res;
    }

    function transformSLIQ_withMOC(aoaSLIQ_raw, aoaMOC){
      if (!aoaSLIQ_raw || aoaSLIQ_raw.length === 0) return aoaSLIQ_raw;

      const headerRaw = aoaSLIQ_raw[0].slice();
      const headerCanon = headerRaw.map(canon);

      let iNetoSLIQ = headerCanon.indexOf('NETO A LIQUIDAR');
      // Neto a Liquidar se deja tal cual (sin multiplicar/dividir)

      let iSLIQCode = -1;
      for (let i=0;i<headerCanon.length;i++){
        if (headerCanon[i].includes('CODIGO')) { iSLIQCode = i; break; }
      }

      const dropNames = new Set(['FALTANTE','ADELANTADAS','LIBERADAS','FALTAN LIBERAR','PND']);
      const keepIdx = [];
      for (let i=0;i<headerCanon.length;i++){
        if (!dropNames.has(headerCanon[i])) keepIdx.push(i);
      }
      const headerKept = keepIdx.map(i => headerRaw[i]);
      const outHeader = [...headerKept, 'Q NASDAQ', 'Control', 'Observación'];

      const { map:mocMap, label:mocLabel } = buildMocNetoMapWithLabel(aoaMOC);

      const out = [outHeader];
      const seenCodes = new Set();

      for (let r=1; r<aoaSLIQ_raw.length; r++){
        const row = aoaSLIQ_raw[r] || [];
        const rowKept = keepIdx.map(i => row[i]);
        let codeKey = '';
        if (iSLIQCode >= 0){
          const codeRaw = row[iSLIQCode];
          codeKey = normalizeCodeKey(codeRaw);
          if (codeKey) seenCodes.add(codeKey);
        }
        const qNasdaq = mocMap.get(codeKey) || 0;
        out.push([...rowKept, qNasdaq, '', '']);
      }

      if (iSLIQCode >= 0){
        let iOutCode = -1;
        for (let i=0;i<outHeader.length;i++){
          if (canon(outHeader[i]).includes('CODIGO')) { iOutCode = i; break; }
        }
        if (iOutCode >= 0){
          for (const [codeKey, q] of mocMap.entries()){
            if (seenCodes.has(codeKey)) continue;
            const row = new Array(outHeader.length).fill('');
            row[iOutCode] = mocLabel.get(codeKey) || codeKey;
            row[outHeader.length - 3] = q;
            out.push(row);
          }
        }
      }

      return out;
    }

    function sortSLIQByControl(aoa){
      if (!aoa || aoa.length <= 1) return aoa;
      const hdr = aoa[0];
      const body = aoa.slice(1);
      const Hc = hdr.map(canon);
      const iNeto = Hc.indexOf('NETO A LIQUIDAR');
      const iQ    = Hc.indexOf('Q NASDAQ');
      if (iNeto < 0 || iQ < 0) return aoa;

      body.sort((a,b)=>{
        const controlA = (coerceNumber(a[iNeto])||0) - (coerceNumber(a[iQ])||0);
        const controlB = (coerceNumber(b[iNeto])||0) - (coerceNumber(b[iQ])||0);
        const flagA = controlA === 0 ? 1 : 0;
        const flagB = controlB === 0 ? 1 : 0;
        return flagA - flagB;
      });

      return [hdr, ...body];
    }

    function addFormulasToSLIQ(ws, header, rowCount){
      if (!header || header.length===0 || rowCount<=1) return;
      const Hc = header.map(canon);
      const iNetoSLIQ = Hc.indexOf('NETO A LIQUIDAR');
      const iQNasdaq  = Hc.indexOf('Q NASDAQ');
      const iControl  = Hc.indexOf('CONTROL');
      const iObs      = Hc.indexOf('OBSERVACION');
      if (iNetoSLIQ<0 || iQNasdaq<0 || iControl<0 || iObs<0) return;

      for (let r=2; r<=rowCount; r++){
        const rowIdx = r - 1;

        const addrNeto = XLSX.utils.encode_cell({c:iNetoSLIQ, r:rowIdx});
        const addrQ    = XLSX.utils.encode_cell({c:iQNasdaq,  r:rowIdx});
        let cellN = ws[addrNeto];
        let cellQ = ws[addrQ];

        if (!cellN || cellN.v === undefined || cellN.v === null || cellN.v === '') {
          ws[addrNeto] = { t:'n', v:0 };
        }
        if (!cellQ || cellQ.v === undefined || cellQ.v === null || cellQ.v === '') {
          ws[addrQ] = { t:'n', v:0 };
        }

        const cNeto = XLSX.utils.encode_col(iNetoSLIQ);
        const cQ    = XLSX.utils.encode_col(iQNasdaq);
        const cCtrl = XLSX.utils.encode_col(iControl);

        ws[XLSX.utils.encode_cell({c:iControl, r:rowIdx})] = { t:'n', f:`${cNeto}${r}-${cQ}${r}` };
        ws[XLSX.utils.encode_cell({c:iObs, r:rowIdx})] = { t:'s', f:`IF(${cCtrl}${r}=0,"OK","REVISAR")` };
      }

      const ref = ws['!ref'] || `A1:${XLSX.utils.encode_col(Math.max(iObs,iControl))}${rowCount}`;
      const rng = XLSX.utils.decode_range(ref);
      rng.e.c = Math.max(rng.e.c, Math.max(iObs,iControl));
      rng.e.r = Math.max(rng.e.r, rowCount-1);
      ws['!ref'] = XLSX.utils.encode_range(rng);
    }

    // =========================
    // Helpers orden/formato
    // =========================
    function sortAOAByColumnNameAsc(aoa, colName){
      if (!aoa || aoa.length<=2) return aoa;
      const Hc = aoa[0].map(canon);
      const idx = Hc.indexOf(canon(colName));
      if (idx < 0) return aoa;
      const body = aoa.slice(1).slice();
      body.sort((a,b)=>{
        const av = coerceNumber(a[idx]) ?? 0;
        const bv = coerceNumber(b[idx]) ?? 0;
        return av - bv;
      });
      return [aoa[0], ...body];
    }

    function sortNeg992ByComputedTotalAsc(aoa){
      if (!aoa || aoa.length<=2) return aoa;
      const Hc = aoa[0].map(canon);
      const iSaldo = Hc.indexOf('SALDO NEGATIVOS');
      const iQty   = Hc.indexOf('QTY BYMA');
      const iByma  = Hc.indexOf('GARANTIAS BYMA');
      const iOtros = Hc.indexOf('OTROS');
      if (iSaldo<0 || iQty<0 || iByma<0 || iOtros<0) return aoa;
      const body = aoa.slice(1).slice();
      body.sort((a,b)=>{
        const at = (coerceNumber(a[iSaldo])||0) + (coerceNumber(a[iQty])||0) + (coerceNumber(a[iByma])||0) + (coerceNumber(a[iOtros])||0);
        const bt = (coerceNumber(b[iSaldo])||0) + (coerceNumber(b[iQty])||0) + (coerceNumber(b[iByma])||0) + (coerceNumber(b[iOtros])||0);
        return at - bt;
      });
      return [aoa[0], ...body];
    }

    function sortMOCByCodigoThenComitente(aoa){
      if (!aoa || aoa.length <= 1) return aoa;
      const hdr = aoa[0];
      const body = aoa.slice(1);
      const Hc = hdr.map(canon);
      const iCod = Hc.indexOf('CODIGO');
      const iCom = Hc.indexOf('COMITENTE');
      if (iCod < 0 && iCom < 0) return aoa;

      body.sort((a,b)=>{
        const ac = coerceNumber(a[iCod]) ?? a[iCod];
        const bc = coerceNumber(b[iCod]) ?? b[iCod];
        if (ac < bc) return -1;
        if (ac > bc) return 1;
        const acom = coerceNumber(a[iCom]) ?? a[iCom];
        const bcom = coerceNumber(b[iCom]) ?? b[iCom];
        if (acom < bcom) return -1;
        if (acom > bcom) return 1;
        return 0;
      });

      return [hdr, ...body];
    }

    function freezeHeader(ws){
      ws['!freeze'] = { xSplit:0, ySplit:1, topLeftCell:'A2' };
    }

    function applyAccountingFormat(ws, header, colNames){
      if (!ws || !header || !header.length || !colNames || !colNames.length) return;
      const Hc = header.map(canon);
      const targetIdx = [];
      colNames.forEach(name=>{
        const idx = Hc.indexOf(canon(name));
        if (idx >= 0) targetIdx.push(idx);
      });
      if (!targetIdx.length) return;
      const ref = ws['!ref'];
      if (!ref) return;
      const rng = XLSX.utils.decode_range(ref);
      const numFmt = '_-* #,##0_-;_* -#,##0_-;_-* "-"_-;_-@_-';

      for (let r = 1; r <= rng.e.r; r++){
        for (const cIdx of targetIdx){
          const addr = XLSX.utils.encode_cell({c:cIdx, r});
          const cell = ws[addr];
          if (!cell) continue;
          if (typeof cell.v === 'number' && cell.t !== 'n') cell.t = 'n';
          cell.z = numFmt;
        }
      }
    }

    // =========================
    // MOC MAE (map y aplicación a MOC)
    // =========================
    function buildMaeMap(aoaMae){
      if (!aoaMae || !aoaMae.length) return new Map();

      // Buscar fila header real (por si aparece alguna basura arriba)
      let headerRowIndex = 0;
      for (let i=0; i<aoaMae.length; i++){
        const row = aoaMae[i] || [];
        const hc = row.map(canon);
        if (hc.includes('COMITENTE') && hc.includes('CODIGO') && hc.includes('COMPRA') && hc.includes('VENTA')){
          headerRowIndex = i;
          break;
        }
      }
      const sliced = aoaMae.slice(headerRowIndex);
      const norm = trimHeaders(sliced);

      const H = norm[0].map(canon);
      const iCom  = H.indexOf('COMITENTE');
      const iCod  = H.indexOf('CODIGO');
      const iComp = H.indexOf('COMPRA');
      const iVent = H.indexOf('VENTA');
      if (iCom<0 || iCod<0 || iComp<0 || iVent<0) return new Map();

      const map = new Map();
      for (let r=1; r<norm.length; r++){
        const row = norm[r];
        const com = coerceNumber(row[iCom]);
        const codRaw = row[iCod];
        if (com == null || codRaw == null || codRaw === '') continue;
        const codKey = canon(codRaw);

        const compra = coerceNumber(row[iComp]) || 0;
        const venta  = coerceNumber(row[iVent]) || 0;
        const maeVal = compra + venta; // Opción A: sumar todas

        const key = com + '|' + codKey;
        map.set(key, (map.get(key) || 0) + maeVal);
      }
      return map;
    }

    function applyMaeToMOC(aoaMOC, maeMap){
      if (!aoaMOC || aoaMOC.length<=1) return aoaMOC;
      const hdr = aoaMOC[0];
      const Hc = hdr.map(canon);
      const iCom   = Hc.indexOf('COMITENTE');
      const iCod   = Hc.indexOf('CODIGO');
      const iComp  = Hc.indexOf('COMPRAS');
      const iVent  = Hc.indexOf('VENTAS');
      const iMae   = Hc.indexOf('MAE');
      const iNeto  = Hc.indexOf('NETO');
      if (iCom<0 || iCod<0 || iComp<0 || iVent<0 || iMae<0 || iNeto<0) return aoaMOC;

      for (let r=1; r<aoaMOC.length; r++){
        const row = aoaMOC[r];
        const com = coerceNumber(row[iCom]);
        const codRaw = row[iCod];
        const key = (com==null ? '' : com) + '|' + canon(codRaw);

        const maeVal = maeMap.size ? (maeMap.get(key) || 0) : 0;
        row[iMae] = maeVal;

        const comp = coerceNumber(row[iComp]) || 0;
        const vent = coerceNumber(row[iVent]) || 0;
        row[iNeto] = comp + vent + maeVal; // numérico interno
      }
      return aoaMOC;
    }

    function addFormulasToMOCSheet(ws, header, rowCount){
      if (!ws || !header || !header.length || rowCount<=1) return;
      const Hc = header.map(canon);
      const iComp = Hc.indexOf('COMPRAS');
      const iVent = Hc.indexOf('VENTAS');
      const iMae  = Hc.indexOf('MAE');
      const iNeto = Hc.indexOf('NETO');
      if (iComp<0 || iVent<0 || iMae<0 || iNeto<0) return;

      const cComp = XLSX.utils.encode_col(iComp);
      const cVent = XLSX.utils.encode_col(iVent);
      const cMae  = XLSX.utils.encode_col(iMae);

      for (let r=2; r<=rowCount; r++){
        const addrNeto = XLSX.utils.encode_cell({c:iNeto, r:r-1});
        ws[addrNeto] = { t: 'n', f: `${cComp}${r}+${cVent}${r}+${cMae}${r}` };
      }

      const ref = ws['!ref'] || `A1:${XLSX.utils.encode_col(Math.max(iNeto,iMae))}${rowCount}`;
      const rng = XLSX.utils.decode_range(ref);
      rng.e.c = Math.max(rng.e.c, Math.max(iNeto,iMae));
      rng.e.r = Math.max(rng.e.r, rowCount-1);
      ws['!ref'] = XLSX.utils.encode_range(rng);
    }

    // =========================
    // Estado
    // =========================
    let wbMOC=null, wbNEG=null, wbAsig=null, wbLista=null, wbNeix=null;
    let aoaMOC=null, aoaASIG=null;
    let aoaNEG_ALL=null, aoaNEG_OTROS=null, aoaNEG_992=null;
    let aoaSLIQ=null;

    const validar = async () => {
      statusEl.innerHTML='';
      const fMOC  = $('#fileMOC').files[0];
      const fMAE  = $('#fileMAE').files[0];
      const fNEG  = $('#fileNeg').files[0];
      const fAsig = $('#fileAsignaciones').files[0];
      const fLista= $('#fileLista').files[0];
      const fNeix = $('#fileNeix').files[0];
      const fSLIQ = $('#fileSLIQ').files[0];

      if (!fMOC) setTag('Falta archivo MOC (xlsx)','bad');
      if (!fNEG) setTag('Falta archivo Saldos Negativos (xlsx)','bad');
      if (!fMOC || !fNEG) return;

      // MOC
      try{
        wbMOC = await readWorkbook(fMOC);
        const name = wbMOC.SheetNames[0];
        aoaMOC = transformMOCv2(sheetToAOA(wbMOC.Sheets[name]));
        setTag(`MOC: hoja "${name}" procesada.`,'ok');
      }catch(e){ console.error(e); setTag('Error leyendo MOC: '+e.message,'bad'); }

      // MOC MAE
      let maeMap = new Map();
      if (fMAE){
        try{
          const aoaMae = await readCSVToAOA(fMAE);
          maeMap = buildMaeMap(aoaMae);
          setTag(`MOC MAE: leído (keys: ${maeMap.size}).`,'ok');
        }catch(e){
          console.error(e);
          setTag('Error leyendo MOC MAE (csv): '+e.message,'warn');
        }
      } else {
        setTag('MOC MAE no adjuntado: MAE se considera 0.','warn');
      }
      if (aoaMOC && aoaMOC.length>1){
        aoaMOC = applyMaeToMOC(aoaMOC, maeMap);
      }

      // SALDOS NEGATIVOS
      try{
        wbNEG = await readWorkbook(fNEG);
        const name = wbNEG.SheetNames[0];
        aoaNEG_ALL = transformNEGv2(sheetToAOA(wbNEG.Sheets[name]));
        const hdr = aoaNEG_ALL[0], body = aoaNEG_ALL.slice(1);
        aoaNEG_992   = [hdr, ...body.filter(r => r[0]===992)];
        aoaNEG_OTROS = [hdr, ...body.filter(r => r[0]!==992)];
        setTag(`Saldos Negativos: hoja "${name}" procesada (split 992).`,'ok');
      }catch(e){ console.error(e); setTag('Error leyendo Saldos Negativos: '+e.message,'bad'); }

      // ASIGNACIONES
      if (fAsig){
        try{
          wbAsig = await readWorkbook(fAsig);
          const name = wbAsig.SheetNames[0];
          aoaASIG = transformASIGN(sheetToAOA(wbAsig.Sheets[name]));
          setTag(`Asignaciones: hoja "${name}" procesada.`,'ok');
        }catch(e){ console.error(e); setTag('Error leyendo Asignaciones: '+e.message,'bad'); }
      } else {
        aoaASIG = null;
        setTag('Asignaciones no adjuntado - se exportará sin esta hoja.','warn');
      }

      // BYMA + MAE->OTROS (SALDOS NEGATIVOS)
      let bymaMap = new Map();
      const fListaExists = !!fLista;
      if (fListaExists){
        try{
          wbLista = await readWorkbook(fLista);
          const name = wbLista.SheetNames[0];
          bymaMap = buildBymaMap(sheetToAOA(wbLista.Sheets[name]));

          // SALDOS NEGATIVOS (OTROS): aplica MAE si hay match
          aoaNEG_OTROS = mergeBymaToNeg(aoaNEG_OTROS, bymaMap, maeMap, true);

          // SALDOS NEGATIVOS 992: NO aplica MAE (queda como siempre)
          aoaNEG_992   = mergeBymaToNeg(aoaNEG_992,   bymaMap, maeMap, false);

          setTag(`BYMA: merge aplicado. (MAE->OTROS en SALDOS NEGATIVOS: ${fMAE ? 'sí' : 'no'})`,'ok');
        }catch(e){
          console.error(e);
          setTag('Error leyendo/merging BYMA: '+e.message,'warn');
        }
      } else {
        setTag('No se adjuntó Lista BYMA: Saldos quedan sin BYMA/OTROS/Total/Observación.','warn');
      }

      // EMISIONES 992
      if (fNeix){
        try{
          wbNeix = await readWorkbook(fNeix);
          const name = wbNeix.SheetNames[0];
          const neixMap = buildNeixMap(sheetToAOA(wbNeix.Sheets[name]));
          aoaNEG_992 = applyNeixToNeg992(aoaNEG_992, neixMap);
          aoaNEG_992 = reorderNeg992(aoaNEG_992);
          setTag(`Emisiones 992: agregado Symbol y Qty BYMA a 'SALDOS NEGATIVOS 992'.`,'ok');
          setTag('SALDOS NEGATIVOS 992: columnas reordenadas.','ok');
        }catch(e){ console.error(e); setTag('Error leyendo/merging Emisiones 992: '+e.message,'warn'); }
      } else {
        setTag('No se adjuntó Emisiones 992: columnas Symbol/Qty BYMA no se agregan.','warn');
      }

      // SLIQ
      aoaSLIQ = null;
      if (fSLIQ){
        try {
          aoaSLIQ = await readCSVToAOA(fSLIQ);
          if (aoaSLIQ && aoaSLIQ.length) {
            setTag(`Control SLIQ: CSV leído (${aoaSLIQ.length-1} filas).`,'ok');
          } else {
            setTag('Control SLIQ: CSV vacío o sin datos.','warn');
          }
        } catch(e){
          console.error(e);
          setTag('Error leyendo Control SLIQ (csv): '+e.message,'warn');
        }
      } else {
        setTag('Control SLIQ no adjuntado - se exportará sin esta hoja.','warn');
      }

      if ((!aoaMOC||!aoaMOC.length) || (!aoaNEG_OTROS||aoaNEG_OTROS.length<=1) || (!aoaNEG_992||aoaNEG_992.length<=1))
        setTag('Faltan datos para exportar.','bad');
      else
        setTag('Listo para exportar.','ok');
    };

    // =========================
    // Fórmulas saldos
    // =========================
    function addFormulasToNegSheet(ws, rowCount){
      for(let r=2; r<=rowCount; r++){
        ws[XLSX.utils.encode_cell({c:7, r:r-1})] = { t:'n', f:`E${r}+F${r}+G${r}` };
        ws[XLSX.utils.encode_cell({c:8, r:r-1})] = { t:'s', f:`IF(H${r}>=0,"OK","REVISAR")` };
      }
      const ref = ws['!ref'] || `A1:I${rowCount}`;
      const rng = XLSX.utils.decode_range(ref);
      rng.e.c = Math.max(rng.e.c, 8); rng.e.r = Math.max(rng.e.r, rowCount-1);
      ws['!ref'] = XLSX.utils.encode_range(rng);
    }

    function addFormulasToNeg992Sheet(ws, header, rowCount){
      const Hc = header.map(canon);
      const iSaldo = Hc.indexOf('SALDO NEGATIVOS');
      const iQty   = Hc.indexOf('QTY BYMA');
      const iByma  = Hc.indexOf('GARANTIAS BYMA');
      const iOtros = Hc.indexOf('OTROS');
      const iTotal = Hc.indexOf('TOTAL');
      const iObs   = Hc.indexOf('OBSERVACION');
      if (iSaldo<0 || iQty<0 || iByma<0 || iOtros<0 || iTotal<0 || iObs<0) return;

      for(let r=2; r<=rowCount; r++){
        const cSaldo = XLSX.utils.encode_col(iSaldo);
        const cQty   = XLSX.utils.encode_col(iQty);
        const cByma  = XLSX.utils.encode_col(iByma);
        const cOtros = XLSX.utils.encode_col(iOtros);
        const cTotal = XLSX.utils.encode_col(iTotal);
        const cObs   = XLSX.utils.encode_col(iObs);
        ws[XLSX.utils.encode_cell({c:iTotal, r:r-1})] = { t:'n', f:`${cSaldo}${r}+${cQty}${r}+${cByma}${r}+${cOtros}${r}` };
        ws[XLSX.utils.encode_cell({c:iObs,   r:r-1})] = { t:'s', f:`IF(${cTotal}${r}>=0,"OK","REVISAR")` };
      }

      const ref = ws['!ref'] || `A1:${XLSX.utils.encode_col(Math.max(iObs,iTotal))}${rowCount}`;
      const rng = XLSX.utils.decode_range(ref);
      rng.e.c = Math.max(rng.e.c, Math.max(iObs,iTotal));
      rng.e.r = Math.max(rng.e.r, rowCount-1);
      ws['!ref'] = XLSX.utils.encode_range(rng);
    }

    // =========================
    // EXPORTAR
    // =========================
    const exportar = () => {
      statusEl.innerHTML='';
      if (!aoaMOC || !aoaNEG_OTROS || !aoaNEG_992){
        setTag('Primero validá todos los archivos requeridos.','bad');
        return;
      }

      const hoy = new Date();
      const dd = String(hoy.getDate()).padStart(2,'0');
      const mm = String(hoy.getMonth()+1).toString().padStart(2,'0');
      const yyyy = hoy.getFullYear();
      const nombreArchivo = `MOC ${dd}-${mm}-${yyyy} DEFINITIVO.xlsx`;

      const wbOut = XLSX.utils.book_new();

      // MOC
      const aoaMOC_sorted = sortMOCByCodigoThenComitente(aoaMOC);
      const wsMOC = aoaToSheet(aoaMOC_sorted);
      addFormulasToMOCSheet(wsMOC, aoaMOC_sorted[0], aoaMOC_sorted.length);
      freezeHeader(wsMOC);
      XLSX.utils.book_append_sheet(wbOut, wsMOC, 'MOC');

      // ASIGNACIONES
      if (aoaASIG && aoaASIG.length > 0) {
        const wsASIG = aoaToSheet(aoaASIG);
        freezeHeader(wsASIG);
        XLSX.utils.book_append_sheet(wbOut, wsASIG, 'ASIGNACIONES_PENDIENTES');
      }

      // SALDOS NEGATIVOS
      const aoaNegSorted = sortAOAByColumnNameAsc(aoaNEG_OTROS, 'Total');
      const wsNeg = aoaToSheet(aoaNegSorted);
      addFormulasToNegSheet(wsNeg, aoaNegSorted.length);
      freezeHeader(wsNeg);
      applyAccountingFormat(wsNeg, aoaNegSorted[0], ['Neto','Cantidad','Saldo Negativos','Garantías BYMA','OTROS','Total']);
      XLSX.utils.book_append_sheet(wbOut, wsNeg, 'SALDOS NEGATIVOS');

      // SALDOS NEGATIVOS 992
      const aoaNeg992Sorted = sortNeg992ByComputedTotalAsc(aoaNEG_992);
      const wsNeg992 = aoaToSheet(aoaNeg992Sorted);
      addFormulasToNeg992Sheet(wsNeg992, aoaNeg992Sorted[0], aoaNeg992Sorted.length);
      freezeHeader(wsNeg992);
      applyAccountingFormat(wsNeg992, aoaNeg992Sorted[0], ['Neto','Cantidad','Saldo Negativos','Qty BYMA','Garantías BYMA','OTROS','Total']);
      XLSX.utils.book_append_sheet(wbOut, wsNeg992, 'SALDOS NEGATIVOS 992');

      // Control SLIQ
      if (aoaSLIQ && aoaSLIQ.length > 0){
        const aoaSLIQ_out = transformSLIQ_withMOC(aoaSLIQ, aoaMOC);
        const aoaSLIQ_sorted = sortSLIQByControl(aoaSLIQ_out);
        const wsSLIQ = aoaToSheet(aoaSLIQ_sorted);
        addFormulasToSLIQ(wsSLIQ, aoaSLIQ_sorted[0], aoaSLIQ_sorted.length);
        freezeHeader(wsSLIQ);
        XLSX.utils.book_append_sheet(wbOut, wsSLIQ, 'Control SLIQ');
      }

      XLSX.writeFile(wbOut, nombreArchivo);
      setTag(`Exportado: ${nombreArchivo}`,'ok');
    };

    const generateVentas = (aoaM) => {
      if (!aoaM || aoaM.length<=1) return null;
      const hdr = aoaM[0], Hc = hdr.map(canon);
      const iCom = Hc.indexOf('COMITENTE');
      const iCod = Hc.indexOf('CODIGO');
      const iVen = Hc.indexOf('VENTAS');
      if (iCom<0 || iCod<0 || iVen<0) return null;
      const outHdr = ['Comitente','Codigo','Ventas'];
      const out = [outHdr];
      for (let r=1; r<aoaM.length; r++){
        const row = aoaM[r];
        const ventas = coerceNumber(row[iVen]);
        if (ventas !== null && ventas !== 0){
          out.push([row[iCom], row[iCod], ventas]);
        }
      }
      return out.length > 1 ? out : null;
    };

    const exportarVentas = async () => {
  console.log('=== EXPORTAR VENTAS INICIADO ===');
  statusEl.innerHTML='';
  
  if (!aoaMOC || aoaMOC.length<=1){
    setTag('Primero valida el archivo MOC.','bad');
    return;
  }

  const aoaVentas = generateVentas(aoaMOC);
  if (!aoaVentas || aoaVentas.length<=1){
    setTag('No hay ventas para exportar (todas son 0).','warn');
    return;
  }

  const hoy = new Date();
  const dd = String(hoy.getDate()).padStart(2,'0');
  const mm = String(hoy.getMonth()+1).padStart(2,'0');
  const yyyy = hoy.getFullYear();
  const nombreArchivo = `VENTAS ${dd}-${mm}-${yyyy}.xlsx`;

  console.log('Generando workbook...');
  const wbOut = XLSX.utils.book_new();
  const wsV = aoaToSheet(aoaVentas);
  freezeHeader(wsV);
  XLSX.utils.book_append_sheet(wbOut, wsV, 'VENTAS');

  console.log('Convirtiendo a blob...');
  const blob = XLSX.write(wbOut, { bookType: 'xlsx', type: 'array' });
  const file = new Blob([blob], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });

  console.log('Preparando FormData...');
  const formData = new FormData();
  formData.append('file', file, nombreArchivo);

  console.log('Enviando petición a /save_excel...');
  
  try {
    const res = await fetch('/save_excel', {
      method: 'POST',
      body: formData
    });
    
    console.log('Respuesta recibida:', res.status);
    const msg = await res.text();
    console.log('Mensaje:', msg);
    setTag(msg, res.ok ? 'ok' : 'bad');
  } catch (err) {
    console.error('ERROR en fetch:', err);
    setTag('Error al guardar el archivo: ' + err.message, 'bad');
  }
};


    document.getElementById('btnValidar').addEventListener('click', validar);
    document.getElementById('btnExport').addEventListener('click', exportar);
    document.getElementById('btnExportVentas').addEventListener('click', exportarVentas);
  </script>
</body>
</html>
